Microsoft (R) Macro Assembler Version 14.00.23026.0	    11/24/15 16:11:31
(Program6.asm						     Page 1 - 1


				TITLE            (Program6.asm)
				;// This program uses stack frames
				;//
				;// This program will take in as input a four digit hex number
				;// from keyboard. A proc will handle the "stuff" to convert it
				;// back to its original form (from ascii representation) and pass
				;// its value to eax
				;//
				;//---------------------------DATA SEGMENT-----------------------------
				INCLUDE Irvine32.inc		;// Irvine32 library
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				INCLUDE Macros.inc			;// Irvine32 Macro library
			      C .NOLIST
			      C .LIST
			      C 

				;// Globals
 = 00000010				Base_16 = 16			;// variable to keep base 16 for hex
 = 00001000				Sixteen_Raised_Three = 4096 
 = 00000100				Sixteen_Raised_Two	 = 256
 = 00000010				Sixteen_Raised_One	 = 16 
 = 00000001				Sixteen_Raised_Zero  = 1 
					
 00000000			.data
				;// Variables
 00000000  0000000A [			HexNum_ASCII  DWORD 10 DUP(0) ;// Variable that keeps user input
	    00000000
	   ]
 00000028 00000000			HexNum_Actual DWORD 0		;// Variable to hold Actual representaion
 0000002C 00000000			count	    DWORD ?	     ;// Count variable 
 00000030 00				decision	    BYTE	?		;// Variable to hold decision

				;// Prompts
 00000031 50 6C 65 61 73		Msg1	BYTE "Please enter a four digit hex number below!", 0
	   65 20 65 6E 74
	   65 72 20 61 20
	   66 6F 75 72 20
	   64 69 67 69 74
	   20 68 65 78 20
	   6E 75 6D 62 65
	   72 20 62 65 6C
	   6F 77 21 00
 0000005D 5B 50 52 45 53		Msg2 BYTE "[PRESS ENTER after input]-----> ", 0
	   53 20 45 4E 54
	   45 52 20 61 66
	   74 65 72 20 69
	   6E 70 75 74 5D
	   2D 2D 2D 2D 2D
	   3E 20 00
				;//---------------------------CODE SEGMENT-----------------------------
 00000000			.code
				;// ***************Prototypes***************
				Get_Hex PROTO,				
					HexNum:PTR DWORD

 00000000			Start_Over:
				;// ************** BEGIN MAIN **************
 00000000			main PROC

				;// Prompt user for a string
 00000000  BA 00000031 R		mov	edx, OFFSET Msg1
 00000005  E8 00000000 E		call WriteString
 0000000A  E8 00000000 E		call Crlf
 0000000F  BA 0000005D R		mov	edx, OFFSET Msg2
 00000014  E8 00000000 E		call WriteString

				;// Read strung 	
 00000019  BA 00000000 R		mov	edx, OFFSET HexNum_ASCII 
 0000001E  B9 00000005			mov  ecx, 5  						;// max characters + null terminator
 00000023  E8 00000000 E		call ReadString					;// input the string
 00000028  A3 0000002C R		mov	count, eax					;// number of characters
 0000002D  E8 00000000 E		call CRLF 

				;// Get the hex values represented by ascii
					INVOKE Get_Hex, ADDR HexNum_ASCII 		;// value will be returned in eax 
 00000032  68 00000000 R   *	    push   OFFSET HexNum_ASCII
 00000037  E8 000000DE	   *	    call   Get_Hex
 0000003C  A3 00000028 R			mov	HexNum_Actual, eax
						;// if ebx = 0001 exit program
 00000041  83 FB 01				cmp	ebx, 0001
 00000044  0F 84 000000C9			je	Quit 
				;// Show user input hex number
					mWrite "User Supplied: "
 0000007E		     1		.data		
 0000007E 55 73 65 72 20     1		??0000 BYTE "User Supplied: ",0	
	   53 75 70 70 6C
	   69 65 64 3A 20
	   00
 0000004A		     1		.code
 0000004A  52		     1		push	edx
 0000004B  BA 0000007E R     1		mov	edx,OFFSET ??0000
 00000050  E8 00000000 E     1		call	WriteString
 00000055  5A		     1		pop	edx

				;// Load number and count
 00000056  BE 00000000 R		mov	esi, OFFSET HexNum_ASCII			;// load number to element
 0000005B  B9 00000003			mov	ecx, 3						;// load count 
 00000060			Show:
 00000060  8A 06			mov	al, [esi]						;// esi => first num
 00000062  E8 00000000 E		call	WriteChar 
 00000067  B0 2D			mov	al, '-'
 00000069  E8 00000000 E		call WriteChar 
 0000006E  46				inc	esi 
 0000006F  E2 EF			Loop Show
					
				;// Loop ended one char early so write it out
 00000071  8A 06			mov al, [esi]
 00000073  E8 00000000 E		call WriteChar 
 00000078  E8 00000000 E		call Crlf
 0000007D  E8 00000000 E		call Crlf
					
				;// Show user acual number representation
					mWrite "Hex Number is: "	
 0000008E		     1		.data		
 0000008E 48 65 78 20 4E     1		??0001 BYTE "Hex Number is: ",0	
	   75 6D 62 65 72
	   20 69 73 3A 20
	   00
 00000082		     1		.code
 00000082  52		     1		push	edx
 00000083  BA 0000008E R     1		mov	edx,OFFSET ??0001
 00000088  E8 00000000 E     1		call	WriteString
 0000008D  5A		     1		pop	edx
					
 0000008E  A1 00000028 R		mov	eax, HexNum_Actual 
 00000093  BB 00000002			mov	ebx, TYPE WORD				;// Print out hex in WORD style (2 bytes)
 00000098  E8 00000000 E		call WriteHexB
 0000009D  E8 00000000 E		call Crlf	
 000000A2  E8 00000000 E		call Crlf				
						 

				;// Ask if user wants to try again
					mWrite "Would you like to do it again? (Y/y): "
 0000009E		     1		.data		
 0000009E 57 6F 75 6C 64     1		??0002 BYTE "Would you like to do it again? (Y/y): ",0	
	   20 79 6F 75 20
	   6C 69 6B 65 20
	   74 6F 20 64 6F
	   20 69 74 20 61
	   67 61 69 6E 3F
	   20 28 59 2F 79
	   29 3A 20 00
 000000A7		     1		.code
 000000A7  52		     1		push	edx
 000000A8  BA 0000009E R     1		mov	edx,OFFSET ??0002
 000000AD  E8 00000000 E     1		call	WriteString
 000000B2  5A		     1		pop	edx
 000000B3  BA 00000030 R		mov	edx, OFFSET decision 
 000000B8  B9 00000002			mov  ecx, 2  						;// max characters + null terminator
 000000BD  E8 00000000 E		call ReadString					;// input the string
										
 000000C2			check:	
					.IF (decision == 'Y') || (decision == 'y') 
 000000C2  80 3D 00000030 R
	   59		   *	    cmp    decision, 'Y'
 000000C9  74 09	   *	    je	@C0002
 000000CB  80 3D 00000030 R
	   79		   *	    cmp    decision, 'y'
 000000D2  75 0C	   *	    jne    @C0001
 000000D4		   *@C0002:
					;// If a repeat clear screen
 000000D4  E8 00000000 E			call Clrscr
 000000D9  E9 FFFFFF22				jmp	Start_Over 
					.ELSEIF (decision == 'N') || (decision == 'n')
 000000DE  EB 33	   *	    jmp    @C0004
 000000E0		   *@C0001:
 000000E0  80 3D 00000030 R
	   4E		   *	    cmp    decision, 'N'
 000000E7  74 09	   *	    je	@C0006
 000000E9  80 3D 00000030 R
	   6E		   *	    cmp    decision, 'n'
 000000F0  75 04	   *	    jne    @C0005
 000000F2		   *@C0006:
 000000F2  EB 1F				jmp	Quit
					.ELSE
 000000F4  EB 1D	   *	    jmp    @C0008
 000000F6		   *@C0005:
						mWrite "Invalid Decision try again: "
 000000C5		     1		.data		
 000000C5 49 6E 76 61 6C     1		??0003 BYTE "Invalid Decision try again: ",0	
	   69 64 20 44 65
	   63 69 73 69 6F
	   6E 20 74 72 79
	   20 61 67 61 69
	   6E 3A 20 00
 000000F6		     1		.code
 000000F6  52		     1		push	edx
 000000F7  BA 000000C5 R     1		mov	edx,OFFSET ??0003
 000000FC  E8 00000000 E     1		call	WriteString
 00000101  5A		     1		pop	edx
 00000102  BA 00000030 R			mov	edx, OFFSET decision 
 00000107  B9 00000002				mov  ecx, 2  						;// max characters + null terminator
 0000010C  E8 00000000 E			call ReadString					;// input the string
 00000111  E2 AF				Loop check
					.ENDIF
 00000113		   *@C0008:
 00000113		   *@C0004:
					
 00000113			Quit:
				;// Exit main
					exit
 00000113  6A 00	   *	    push   +000000000h
 00000115  E8 00000000 E   *	    call   ExitProcess
 0000011A			main ENDP
				;//-----------------------------------SUBROUTINES--------------------------------------
				;// Name: Get_Hex
				;// 
				;// Recieves: 
				;//		HexNum, an address to a variable that hold the string 
				;// Returns:
				;//		eax, the number represented by string 
				;//		ebx, error code if invalid input 
				;//-------------------------------------------------------------------------------------
 0000011A			Get_Hex PROC USES ecx edx esi,
					HexNum:PTR DWORD  
					LOCAL temp: BYTE
					LOCAL retVal: DWORD 

				;// Load first character of esi and set the count to 4 (4 bytes)
 0000011A  55		   *	    push   ebp
 0000011B  8B EC	   *	    mov    ebp, esp
 0000011D  83 C4 F8	   *	    add    esp, 0FFFFFFF8h
 00000120  51		   *	    push   ecx
 00000121  52		   *	    push   edx
 00000122  56		   *	    push   esi
 00000123  8B 75 08			mov	esi, HexNum
 00000126  8B 0D 0000002C R		mov	ecx, count	

				;// Set ebx and edx to zero
 0000012C  BB 00000000			mov  ebx, 0
 00000131  BA 00000000			mov  edx, 0			

				;// Now convert to hex byte by byte 
 00000136			Convert_Hex:
 00000136  8A 06			mov	al, [esi]
 00000138  3C 30			cmp	al, 30h		;// Is al < 30h (ascii representation of 0) ? 
 0000013A  0F 82 00000368		jb   Dont_Care		;//		Yes, jump to dont care 
 00000140  3C 3A			cmp  al, 3Ah		;// Is al > 39h (ascii representation of ':' the character after 9) ? 
 00000142  73 02			jae	Check_Upper	;//		Yes, check to see if letter 
 00000144  72 24			jb	Is_Num		;//		No, then it's a number (since it didnt jump to Dont Care)

 00000146			Check_Upper:
 00000146  3C 41			cmp	al, 41h		;// Is al < 41h ? (ascii representation of 'A')
 00000148  0F 82 0000035A		jb	Dont_Care		;//		Yes, this character doesnt matter 	
 0000014E  3C 46			cmp	al, 46h		;// Is al >= 46h (ascii represnetaion of 'F', last hex letter)
 00000150  77 06			ja	Check_Lower	;//		Yes? CHeck if its a lower case
 00000152  0F 82 00000090		jb	Is_Upper		;//		No? THen its a Upper case

 00000158			Check_Lower:
 00000158  3C 61			cmp	al, 61h		;// Is al < 61h (ascii representation of 'a')
 0000015A  0F 82 00000348		jb	Dont_Care		;//		Yes, this character doesnt matter
 00000160  3C 66			cmp	al, 66h		;// Is al > 66h (ascii representation of 'f', last hex letter)
 00000162  0F 87 00000340		ja	Dont_Care		;//		Yes, character doesnt matter
 00000168  EB 7A			jmp	Is_Lower		;//	This means character is a lower case letter 
					
				;// Jump accordingly 
				;//	.IF (al >= 30h) || (al <= 39h)	;// If al >= '0' or al <= '9'
				;//		jmp	Is_Num				;//		then its a number
				;//	.ELSEIF (al >= 4Dh) || (al <= 5Ah)	;// If al >= 'A' or al <= 'Z'
				;//		jmp	Is_Upper				;//		Then it's an upper case letter
				;//	.ELSEIF (al >= 61h) || (al <= 7Ah)	;// If al >= 'a' or al <= 'z'
				;//		jmp	Is_Lower				;//		Then it's an lower case letter
				;//	.ELSE						;// Else it is a "dont care" value
				;//		jmp	Dont_Care 
				;//	.ENDIF		


					;// Convert to number
 0000016A				Is_Num:
 0000016A  2C 30				sub	al, 30h	
 0000016C  88 45 FF				mov  temp, al 	
 0000016F  B8 00000000				mov eax, 0000
						;// Check what place is is
							;// 0s place?
 00000174  83 F9 01					cmp	ecx, 1		
 00000177  74 52					je	Byte_1
							;// 1s place?
 00000179  83 F9 02					cmp	ecx, 2
 0000017C  74 34					je	Byte_2 
							;// 2s place?
 0000017E  83 F9 03					cmp	ecx, 3
 00000181  74 1A					je	Byte_3
							;// 3s place?
 00000183  83 F9 04					cmp	ecx, 4
 00000186  74 00					je	Byte_4
						
						;// Since its in 3s place, 16^3 = 4096
 00000188					Byte_4:
 00000188  B8 00001000					mov	eax, Sixteen_Raised_Three
 0000018D  8A 5D FF					mov	bl, temp 
 00000190  F7 E3					mul	ebx 
 00000192  89 45 F8					mov	retVal, eax 
 00000195  46						inc  esi
 00000196  49						dec	ecx				;// to far to use LOOP so usea jump instead
 00000197  C6 45 FF 00					mov	temp, 0
 0000019B  75 99					jne	Convert_Hex		
						;// Since its in 2s place, 16^2 = 256
 0000019D					Byte_3:
 0000019D  B8 00000100					mov	eax, Sixteen_Raised_Two
 000001A2  8A 5D FF					mov	bl, temp 
 000001A5  F7 E3					mul	ebx 
 000001A7  01 45 F8					add	retVal, eax 
 000001AA  46						inc  esi
 000001AB  49						dec	ecx				;// to far to use LOOP so usea jump instead
 000001AC  C6 45 FF 00					mov	temp, 0
 000001B0  75 84					jne	Convert_Hex		
						;// Since its in 1s place, 16^1 = 16
 000001B2					Byte_2:
 000001B2  B8 00000010					mov	eax, Sixteen_Raised_One
 000001B7  8A 5D FF					mov	bl, temp 
 000001BA  F7 E3					mul	ebx 
 000001BC  01 45 F8					add	retVal, eax
 000001BF  46						inc  esi
 000001C0  49						dec	ecx				;// to far to use LOOP so usea jump instead
 000001C1  C6 45 FF 00					mov	temp, 0
 000001C5  0F 85 FFFFFF6B				jne	Convert_Hex		
						;// Since its in 1 place, 16^0 = 1
 000001CB					Byte_1:
 000001CB  B8 00000001					mov	eax, Sixteen_Raised_Zero 
 000001D0  8A 5D FF					mov	bl, temp 
 000001D3  F7 E3					mul	ebx 
 000001D5  01 45 F8					add	retVal, eax
 000001D8  46						inc  esi
 000001D9  49						dec	ecx				;// to far to use LOOP so usea jump instead
 000001DA  C6 45 FF 00					mov	temp, 0
 000001DE  0F 85 FFFFFF52				jne	Convert_Hex		

				;// Convert to upper case and change it to the actual number
 000001E4			Is_Lower:
 000001E4  2C 20			sub	al, 20h		;// convert to upper case (20 is offset btwn a upper and lower)
 000001E6  88 06			mov  [esi], al		;// Change the lower case letter 
					
				;// If its an upper case just change it to actual number
 000001E8			Is_Upper:
					;// If al == 'A', then its 10
						.IF (al == 'A')
 000001E8  3C 41	   *	    cmp    al, 'A'
 000001EA  75 75	   *	    jne    @C0009
 000001EC  B8 00000000					mov eax, 0000		;// zero out eax reg
 000001F1					Hex_A:
						;// First Check count which shows us the place
							.IF (ecx == 4)		
 000001F1  83 F9 04	   *	    cmp    ecx, 004h
 000001F4  75 18	   *	    jne    @C000B
							;// Then use 16^3
 000001F6  B8 00001000						mov	eax, Sixteen_Raised_Three
 000001FB  BB 0000000A						mov	ebx, 000Ah 
 00000200  F7 E3						mul	ebx 
 00000202  00 45 FF						add	temp, al
 00000205  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 00000209  E9 00000290	   *	    jmp    @C000D
 0000020E		   *@C000B:
 0000020E  83 F9 03	   *	    cmp    ecx, 003h
 00000211  75 18	   *	    jne    @C000E
							;// Then use 16^2
 00000213  B8 00000100						mov	eax, Sixteen_Raised_Two
 00000218  BB 0000000A						mov	ebx, 000Ah 
 0000021D  F7 E3						mul	ebx 
 0000021F  01 45 F8						add	RetVal, eax 
 00000222  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 00000226  E9 00000273	   *	    jmp    @C0010
 0000022B		   *@C000E:
 0000022B  83 F9 02	   *	    cmp    ecx, 002h
 0000022E  75 14	   *	    jne    @C0011
 00000230  B8 00000010						mov	eax, Sixteen_Raised_One
 00000235  BB 0000000A						mov	ebx, 000Ah 
 0000023A  F7 E3						mul	ebx 
 0000023C  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 0000023F  E9 0000025A	   *	    jmp    @C0013
 00000244		   *@C0011:
 00000244  83 F9 01	   *	    cmp    ecx, 001h
 00000247  0F 85 00000251  *	    jne    @C0014
 0000024D  B8 00000001						mov	eax, Sixteen_Raised_Zero
 00000252  BB 0000000A						mov	ebx, 000Ah 
 00000257  F7 E3						mul	ebx 
 00000259  01 45 F8						add	RetVal, eax 
							.ENDIF
					;// If al == 'B', then its 11
						.ELSEIF (al == 'B')
 0000025C  E9 0000023D	   *	    jmp    @C0016
 00000261		   *@C0009:
 00000261  3C 42	   *	    cmp    al, 'B'
 00000263  75 75	   *	    jne    @C0017
 00000265  B8 00000000					mov eax, 0000		;// zero out eax reg
 0000026A					Hex_B:	
							.IF (ecx == 4)		
 0000026A  83 F9 04	   *	    cmp    ecx, 004h
 0000026D  75 18	   *	    jne    @C0019
							;// Then use 16^3
 0000026F  B8 00001000						mov	eax, Sixteen_Raised_Three
 00000274  BB 0000000B						mov	ebx, 000Bh 
 00000279  F7 E3						mul	ebx 
 0000027B  00 45 FF						add	temp, al
 0000027E  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 00000282  E9 00000217	   *	    jmp    @C001B
 00000287		   *@C0019:
 00000287  83 F9 03	   *	    cmp    ecx, 003h
 0000028A  75 18	   *	    jne    @C001C
							;// Then use 16^2
 0000028C  B8 00000100						mov	eax, Sixteen_Raised_Two
 00000291  BB 0000000B						mov	ebx, 000Bh 
 00000296  F7 E3						mul	ebx 
 00000298  01 45 F8						add	RetVal, eax 
 0000029B  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 0000029F  E9 000001FA	   *	    jmp    @C001E
 000002A4		   *@C001C:
 000002A4  83 F9 02	   *	    cmp    ecx, 002h
 000002A7  75 14	   *	    jne    @C001F
 000002A9  B8 00000010						mov	eax, Sixteen_Raised_One
 000002AE  BB 0000000B						mov	ebx, 000Bh 
 000002B3  F7 E3						mul	ebx 
 000002B5  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 000002B8  E9 000001E1	   *	    jmp    @C0021
 000002BD		   *@C001F:
 000002BD  83 F9 01	   *	    cmp    ecx, 001h
 000002C0  0F 85 000001D8  *	    jne    @C0022
 000002C6  B8 00000001						mov	eax, Sixteen_Raised_Zero
 000002CB  BB 0000000B						mov	ebx, 000Bh 
 000002D0  F7 E3						mul	ebx 
 000002D2  01 45 F8						add	RetVal, eax 
							.ENDIF
					;// If al == 'C', then its 12
						.ELSEIF (al == 'C')
 000002D5  E9 000001C4	   *	    jmp    @C0024
 000002DA		   *@C0017:
 000002DA  3C 43	   *	    cmp    al, 'C'
 000002DC  75 75	   *	    jne    @C0025
 000002DE  B8 00000000					mov eax, 0000		;// zero out eax reg
 000002E3					Hex_C:
							.IF (ecx == 4)		
 000002E3  83 F9 04	   *	    cmp    ecx, 004h
 000002E6  75 18	   *	    jne    @C0027
							;// Then use 16^3
 000002E8  B8 00001000						mov	eax, Sixteen_Raised_Three
 000002ED  BB 0000000C						mov	ebx, 000Ch 
 000002F2  F7 E3						mul	ebx 
 000002F4  00 45 FF						add	temp, al
 000002F7  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 000002FB  E9 0000019E	   *	    jmp    @C0029
 00000300		   *@C0027:
 00000300  83 F9 03	   *	    cmp    ecx, 003h
 00000303  75 18	   *	    jne    @C002A
							;// Then use 16^2
 00000305  B8 00000100						mov	eax, Sixteen_Raised_Two
 0000030A  BB 0000000C						mov	ebx, 000Ch 
 0000030F  F7 E3						mul	ebx 
 00000311  01 45 F8						add	RetVal, eax 
 00000314  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 00000318  E9 00000181	   *	    jmp    @C002C
 0000031D		   *@C002A:
 0000031D  83 F9 02	   *	    cmp    ecx, 002h
 00000320  75 14	   *	    jne    @C002D
 00000322  B8 00000010						mov	eax, Sixteen_Raised_One
 00000327  BB 0000000C						mov	ebx, 000Ch 
 0000032C  F7 E3						mul	ebx 
 0000032E  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 00000331  E9 00000168	   *	    jmp    @C002F
 00000336		   *@C002D:
 00000336  83 F9 01	   *	    cmp    ecx, 001h
 00000339  0F 85 0000015F  *	    jne    @C0030
 0000033F  B8 00000001						mov	eax, Sixteen_Raised_Zero
 00000344  BB 0000000C						mov	ebx, 000Ch 
 00000349  F7 E3						mul	ebx 
 0000034B  01 45 F8						add	RetVal, eax 
							.ENDIF
					;// If al == 'D', then its 13
						.ELSEIF (al == 'D')
 0000034E  E9 0000014B	   *	    jmp    @C0032
 00000353		   *@C0025:
 00000353  3C 44	   *	    cmp    al, 'D'
 00000355  75 75	   *	    jne    @C0033
 00000357  B8 00000000					mov eax, 0000		;// zero out eax reg
 0000035C					Hex_D:
							.IF (ecx == 4)		
 0000035C  83 F9 04	   *	    cmp    ecx, 004h
 0000035F  75 18	   *	    jne    @C0035
							;// Then use 16^3
 00000361  B8 00001000						mov	eax, Sixteen_Raised_Three
 00000366  BB 0000000D						mov	ebx, 000Dh 
 0000036B  F7 E3						mul	ebx 
 0000036D  00 45 FF						add	temp, al
 00000370  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 00000374  E9 00000125	   *	    jmp    @C0037
 00000379		   *@C0035:
 00000379  83 F9 03	   *	    cmp    ecx, 003h
 0000037C  75 18	   *	    jne    @C0038
							;// Then use 16^2
 0000037E  B8 00000100						mov	eax, Sixteen_Raised_Two
 00000383  BB 0000000D						mov	ebx, 000Dh 
 00000388  F7 E3						mul	ebx 
 0000038A  01 45 F8						add	RetVal, eax 
 0000038D  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 00000391  E9 00000108	   *	    jmp    @C003A
 00000396		   *@C0038:
 00000396  83 F9 02	   *	    cmp    ecx, 002h
 00000399  75 14	   *	    jne    @C003B
 0000039B  B8 00000010						mov	eax, Sixteen_Raised_One
 000003A0  BB 0000000D						mov	ebx, 000Dh 
 000003A5  F7 E3						mul	ebx 
 000003A7  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 000003AA  E9 000000EF	   *	    jmp    @C003D
 000003AF		   *@C003B:
 000003AF  83 F9 01	   *	    cmp    ecx, 001h
 000003B2  0F 85 000000E6  *	    jne    @C003E
 000003B8  B8 00000001						mov	eax, Sixteen_Raised_Zero
 000003BD  BB 0000000D						mov	ebx, 000Dh 
 000003C2  F7 E3						mul	ebx 
 000003C4  01 45 F8						add	RetVal, eax 
							.ENDIF
					;// If al == 'E', then its 14
						.ELSEIF (al == 'E')	
 000003C7  E9 000000D2	   *	    jmp    @C0040
 000003CC		   *@C0033:
 000003CC  3C 45	   *	    cmp    al, 'E'
 000003CE  75 6B	   *	    jne    @C0041
 000003D0  B8 00000000					mov eax, 0000		;// zero out eax reg
 000003D5					Hex_E:
							.IF (ecx == 4)		
 000003D5  83 F9 04	   *	    cmp    ecx, 004h
 000003D8  75 18	   *	    jne    @C0043
							;// Then use 16^3
 000003DA  B8 00001000						mov	eax, Sixteen_Raised_Three
 000003DF  BB 0000000E						mov	ebx, 000Eh 
 000003E4  F7 E3						mul	ebx 
 000003E6  00 45 FF						add	temp, al
 000003E9  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 000003ED  E9 000000AC	   *	    jmp    @C0045
 000003F2		   *@C0043:
 000003F2  83 F9 03	   *	    cmp    ecx, 003h
 000003F5  75 18	   *	    jne    @C0046
							;// Then use 16^2
 000003F7  B8 00000100						mov	eax, Sixteen_Raised_Two
 000003FC  BB 0000000E						mov	ebx, 000Eh 
 00000401  F7 E3						mul	ebx 
 00000403  01 45 F8						add	RetVal, eax 
 00000406  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 0000040A  E9 0000008F	   *	    jmp    @C0048
 0000040F		   *@C0046:
 0000040F  83 F9 02	   *	    cmp    ecx, 002h
 00000412  75 11	   *	    jne    @C0049
 00000414  B8 00000010						mov	eax, Sixteen_Raised_One
 00000419  BB 0000000E						mov	ebx, 000Eh 
 0000041E  F7 E3						mul	ebx 
 00000420  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 00000423  EB 79	   *	    jmp    @C004B
 00000425		   *@C0049:
 00000425  83 F9 01	   *	    cmp    ecx, 001h
 00000428  75 74	   *	    jne    @C004C
 0000042A  B8 00000001						mov	eax, Sixteen_Raised_Zero
 0000042F  BB 0000000E						mov	ebx, 000Eh 
 00000434  F7 E3						mul	ebx 
 00000436  01 45 F8						add	RetVal, eax 
							.ENDIF
					;// If al == 'F', then its 15
						.ELSE
 00000439  EB 63	   *	    jmp    @C004E
 0000043B		   *@C0041:
 0000043B  B8 00000000					mov eax, 0000		;// zero out eax reg
 00000440					Hex_F:
							.IF (ecx == 4)		
 00000440  83 F9 04	   *	    cmp    ecx, 004h
 00000443  75 15	   *	    jne    @C004F
							;// Then use 16^3
 00000445  B8 00001000						mov	eax, Sixteen_Raised_Three
 0000044A  BB 0000000F						mov	ebx, 000Fh 
 0000044F  F7 E3						mul	ebx 
 00000451  00 45 FF						add	temp, al
 00000454  C6 45 FF 00						mov	temp, 0000
							.ELSEIF (ecx == 3)
 00000458  EB 44	   *	    jmp    @C0051
 0000045A		   *@C004F:
 0000045A  83 F9 03	   *	    cmp    ecx, 003h
 0000045D  75 15	   *	    jne    @C0052
							;// Then use 16^2
 0000045F  B8 00000100						mov	eax, Sixteen_Raised_Two
 00000464  BB 0000000F						mov	ebx, 000Fh 
 00000469  F7 E3						mul	ebx 
 0000046B  01 45 F8						add	RetVal, eax 
 0000046E  C6 45 FF 00						mov	temp, 0000
							;// Then use 16^1
							.ELSEIF (ecx == 2)
 00000472  EB 2A	   *	    jmp    @C0054
 00000474		   *@C0052:
 00000474  83 F9 02	   *	    cmp    ecx, 002h
 00000477  75 11	   *	    jne    @C0055
 00000479  B8 00000010						mov	eax, Sixteen_Raised_One
 0000047E  BB 0000000F						mov	ebx, 000Fh 
 00000483  F7 E3						mul	ebx 
 00000485  01 45 F8						add	RetVal, eax 
							;// Then use 16^0
							.ELSEIF (ecx == 1)
 00000488  EB 14	   *	    jmp    @C0057
 0000048A		   *@C0055:
 0000048A  83 F9 01	   *	    cmp    ecx, 001h
 0000048D  75 0F	   *	    jne    @C0058
 0000048F  B8 00000001						mov	eax, Sixteen_Raised_Zero
 00000494  BB 0000000F						mov	ebx, 000Fh 
 00000499  F7 E3						mul	ebx 
 0000049B  01 45 F8						add	RetVal, eax 
							.ENDIF
						.ENDIF 
 0000049E		   *@C0058:
 0000049E		   *@C0057:
 0000049E		   *@C0054:
 0000049E		   *@C0051:
 0000049E		   *@C004E:
 0000049E		   *@C0040:
 0000049E		   *@C0032:
 0000049E		   *@C0024:
 0000049E		   *@C0016:
 0000049E		   *@C0014:
 0000049E		   *@C0013:
 0000049E		   *@C0010:
 0000049E		   *@C000D:
 0000049E		   *@C0022:
 0000049E		   *@C0021:
 0000049E		   *@C001E:
 0000049E		   *@C001B:
 0000049E		   *@C0030:
 0000049E		   *@C002F:
 0000049E		   *@C002C:
 0000049E		   *@C0029:
 0000049E		   *@C003E:
 0000049E		   *@C003D:
 0000049E		   *@C003A:
 0000049E		   *@C0037:
 0000049E		   *@C004C:
 0000049E		   *@C004B:
 0000049E		   *@C0048:
 0000049E		   *@C0045:
 0000049E  46					inc	esi 
 0000049F  49					dec	ecx					;// to far to use LOOP so usea jump instead
 000004A0  0F 85 FFFFFC90			jne	Convert_Hex		
 000004A6  EB 18				jmp Leave_Proc				;// Skip dont care

				;// Invalid character return an error code for program to handle 
 000004A8			Dont_Care:
					mWrite <"Error! Invalid Input!",0dh,0ah>
 000000E2		     1		.data		
 000000E2 45 72 72 6F 72     1		??0004 BYTE "Error! Invalid Input!",0dh,0ah,0	
	   21 20 49 6E 76
	   61 6C 69 64 20
	   49 6E 70 75 74
	   21 0D 0A 00
 000004A8		     1		.code
 000004A8  52		     1		push	edx
 000004A9  BA 000000E2 R     1		mov	edx,OFFSET ??0004
 000004AE  E8 00000000 E     1		call	WriteString
 000004B3  5A		     1		pop	edx
 000004B4  BB 00000001			mov	ebx, 00001				;// error code for program to handle
					ret	
 000004B9  5E		   *	    pop    esi
 000004BA  5A		   *	    pop    edx
 000004BB  59		   *	    pop    ecx
 000004BC  C9		   *	    leave  
 000004BD  C2 0004	   *	    ret    00004h

 000004C0			Leave_Proc:	
				;// mov eax the value 
 000004C0  8B 45 F8			mov eax, retVal 
					ret 
 000004C3  5E		   *	    pop    esi
 000004C4  5A		   *	    pop    edx
 000004C5  59		   *	    pop    ecx
 000004C6  C9		   *	    leave  
 000004C7  C2 0004	   *	    ret    00004h
 000004CA			Get_Hex ENDP
				END main
Microsoft (R) Macro Assembler Version 14.00.23026.0	    11/24/15 16:11:31
(Program6.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

IsDefined  . . . . . . . . . . .	Func
Startup  . . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mDump  . . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mShowRegister  . . . . . . . . .	Proc
mShow  . . . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteSpace  . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000000FA Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000004CA Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Get_Hex  . . . . . . . . . . . .	P Near	 0000011A _TEXT	Length= 000003B0 Public STDCALL
  HexNum . . . . . . . . . . . .	DWord	 bp + 00000008
  temp . . . . . . . . . . . . .	Byte	 bp - 00000001
  retVal . . . . . . . . . . . .	DWord	 bp - 00000008
  Convert_Hex  . . . . . . . . .	L Near	 00000136 _TEXT	
  Check_Upper  . . . . . . . . .	L Near	 00000146 _TEXT	
  Check_Lower  . . . . . . . . .	L Near	 00000158 _TEXT	
  Is_Num . . . . . . . . . . . .	L Near	 0000016A _TEXT	
  Byte_4 . . . . . . . . . . . .	L Near	 00000188 _TEXT	
  Byte_3 . . . . . . . . . . . .	L Near	 0000019D _TEXT	
  Byte_2 . . . . . . . . . . . .	L Near	 000001B2 _TEXT	
  Byte_1 . . . . . . . . . . . .	L Near	 000001CB _TEXT	
  Is_Lower . . . . . . . . . . .	L Near	 000001E4 _TEXT	
  Is_Upper . . . . . . . . . . .	L Near	 000001E8 _TEXT	
  Hex_A  . . . . . . . . . . . .	L Near	 000001F1 _TEXT	
  Hex_B  . . . . . . . . . . . .	L Near	 0000026A _TEXT	
  Hex_C  . . . . . . . . . . . .	L Near	 000002E3 _TEXT	
  Hex_D  . . . . . . . . . . . .	L Near	 0000035C _TEXT	
  Hex_E  . . . . . . . . . . . .	L Near	 000003D5 _TEXT	
  Hex_F  . . . . . . . . . . . .	L Near	 00000440 _TEXT	
  Dont_Care  . . . . . . . . . .	L Near	 000004A8 _TEXT	
  Leave_Proc . . . . . . . . . .	L Near	 000004C0 _TEXT	
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000011A Public STDCALL
  Show . . . . . . . . . . . . .	L Near	 00000060 _TEXT	
  check  . . . . . . . . . . . .	L Near	 000000C2 _TEXT	
  Quit . . . . . . . . . . . . .	L Near	 00000113 _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 0000007E _DATA	
??0001 . . . . . . . . . . . . .	Byte	 0000008E _DATA	
??0002 . . . . . . . . . . . . .	Byte	 0000009E _DATA	
??0003 . . . . . . . . . . . . .	Byte	 000000C5 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 000000E2 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
Base_16  . . . . . . . . . . . .	Number	 00000010h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
HexNum_ASCII . . . . . . . . . .	DWord	 00000000 _DATA	
HexNum_Actual  . . . . . . . . .	DWord	 00000028 _DATA	
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
Msg1 . . . . . . . . . . . . . .	Byte	 00000031 _DATA	
Msg2 . . . . . . . . . . . . . .	Byte	 0000005D _DATA	
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
Sixteen_Raised_One . . . . . . .	Number	 00000010h   
Sixteen_Raised_Three . . . . . .	Number	 00001000h   
Sixteen_Raised_Two . . . . . . .	Number	 00000100h   
Sixteen_Raised_Zero  . . . . . .	Number	 00000001h   
Start_Over . . . . . . . . . . .	L Near	 00000000 _TEXT	
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
count  . . . . . . . . . . . . .	DWord	 0000002C _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
decision . . . . . . . . . . . .	Byte	 00000030 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
red  . . . . . . . . . . . . . .	Number	 00000004h   
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
